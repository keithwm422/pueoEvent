/****************************************************************************************
*  pueo/GeomTool.h              The PUEO Geometry Tool 
*  
*  The Geometry tool gives us information about channel mappings, antenna
*  locations, and all that fun stuff. 
* 
*  Cosmin Deaconu <cozzyd@kicp.uchicago.edu>    
*
*  (C) 2023-, The Payload for Ultrahigh Energy Observations (PUEO) Collaboration
* 
*  This file is part of pueoEvent, the ROOT I/O library for PUEO. 
* 
*  pueoEvent is free software: you can redistribute it and/or modify it under the
*  terms of the GNU General Public License as published by the Free Software
*  Foundation, either version 2 of the License, or (at your option) any later
*  version.
* 
*  Foobar is distributed in the hope that it will be useful, but WITHOUT ANY
*  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
*  A PARTICULAR PURPOSE. See the GNU General Public License for more details.
* 
*  You should have received a copy of the GNU General Public License along with
*  Foobar. If not, see <https://www.gnu.org/licenses/
*
****************************************************************************************/ 

#ifndef PUEO_GEOMTOOL_H
#define PUEO_GEOMTOOL_H

//Includes
#include <iostream>
#include <TObject.h>
#include <TMath.h>
#include <TVector3.h>
#include "pueo/Conventions.h"
#include "pueo/GeometryReader.h" 

#include <fstream>
#include <cstring>
#include <string>

#include "TString.h"
#include "TObjArray.h"
#include "TObjString.h"
#include "TVector3.h"






namespace  pueo 
{

  class UsefulEvent; 
  constexpr double C_LIGHT = 299792458; //meters per second


//!  pueo::GeomTool -- The PUEO Geometry Tool
/*!
  This is a utility class of useful thingies that can be used for some of the
  standard conversions that are needed in PUEO analysis. 
  Since we now always read the channel mapping, static usage is no longer really supported. You should always ask for an instance. 

  WARNING: Currently ant is always an antenna index, NOT the antenna number for backwards compatibility reasons. 
  
  \ingroup rootclasses
*/




  class GeomTool 
  {
    public:
    /********************************************************************************************************
    Constructor and destructor functions
    The constructor is private, this should be generated by Instance
    The destructor would be deleted, as this should never be deallocated, but that seems to break
    dictionary generation?. 
    ********************************************************************************************************/
    virtual ~GeomTool()  {;}


    /** 
     * Instance generator. If version_number == 0, uses pueo::Version::get(); 
     * If geometry_source is "", will use default geometry source for that version. 
     * The default can be cahnged with the helper function below. 
     */
    static const GeomTool & Instance( Int_t pueo_version = 0, const char * geometry_source = "" );

    static void setDefaultGeometry(Int_t pueo_version, const std::string & default_source); 
    static const std::string & getDefaultGeometry(Int_t pueo_version = 0); 


    /** Get Ring from antenna index */ 
    ring::ring_t getRingFromAnt(Int_t ant) const;


    //returns surf
    Int_t getSurfChanAntFromRingPhiPol(
               pueo::ring::ring_t ring, Int_t phi, pueo::pol::pol_t pol,
               Int_t &surf, Int_t &chan, Int_t &ant) const; ///< Convert ring-phi-pol to surf-chan-ant

    //returns ring
     ring::ring_t getRingAntPolPhiFromSurfChan(Int_t surf, Int_t chan,
               pueo::ring::ring_t &ring,
               Int_t &ant,
               pueo::pol::pol_t &pol,
               Int_t &phi) const; ///< Convert surf-chan to ring-ant-pol-phi

    //returns phi
    Int_t getPhiRingPolFromSurfChan(Int_t surf, Int_t chan, Int_t & phi, ring::ring_t & ring, pol::pol_t & pol) const; 

    Int_t getChanIndex(Int_t surf, Int_t chan) const;///< Surf + channel to channel index
    Int_t getChanIndexFromRingPhiPol(pueo::ring::ring_t ring,
              Int_t phi,
              pueo::pol::pol_t pol) const; ///< Convert ring-phi-pol to logical index

    Int_t getChanIndexFromAntPol(Int_t ant,
                pueo::pol::pol_t pol) const; ///< Convert ant-pol to logical index

    Int_t getSurfFromAntPol(Int_t ant,pol::pol_t pol) const;
    Int_t getSurfChanFromAntPol(Int_t ant,pol::pol_t pol, Int_t & surf, Int_t & chan) const;
    Int_t getAntPolFromSurfChan(Int_t surf, Int_t chan, Int_t & ant, pol::pol_t & pol) const; 
    Int_t getAntPolFromChanIndex(Int_t chanIndex, Int_t & ant, pol::pol_t & pol) const; 
    pueo::ring::ring_t getRingFromChanIndex(Int_t chanIndex) const;

    Int_t getSurfChanFromChanIndex(Int_t chanIndex, // input channel index
            Int_t &surf,Int_t &chan) const; ///< Convert logical index to  surf and channel

    Int_t getPhiSector(Int_t chan_index) const; ///< phi sector of this channel.

    Int_t getPhiFromAnt(Int_t ant) const; ///< get phi from ant

    Int_t getAntFromPhiRing(Int_t phi, pueo::ring::ring_t ring) const; ///< get antenna number from phi and ring

    Int_t getAntOrientation(Int_t ant) const; ///< Some of the antennas have their orientation reversed relative to nominal. The effect of this is to switch the sign the of the signal (as up is down and left is right). Returns 1 for nominal orientation and -1 for flipped.

    static Double_t getPhiDiff(Double_t firstPhi, Double_t secondPhi); 

    /********************************************************************************************************
    Non-static member functions (requires initialization of class for accessing data)
    ********************************************************************************************************/
    Double_t getDirectionWrtNorth(Int_t phi, Double_t heading) const; ///< Get direction that a phi sector is pointing wrt north.  Also takes heading as a input.

    void getAntXYZ(Int_t ant, Double_t &x, Double_t &y, Double_t &z,
       pueo::pol::pol_t pol=pueo::pol::kVertical) const; ///< get antenna cartesian coordinates (from photogrammetry)

    Double_t getAntZ(Int_t ant, pueo::pol::pol_t pol=pueo::pol::kVertical) const; ///< get antenna z position

    Double_t getAntR(Int_t ant, pueo::pol::pol_t pol=pueo::pol::kVertical) const; ///< get antenna r position

    Double_t getAntPhiPosition(Int_t ant, pueo::pol::pol_t pol=pueo::pol::kVertical) const; ///< get antenna phi position

    Double_t getAntPhiPositionRelToAftFore(Int_t ant, pueo::pol::pol_t pol=pueo::pol::kVertical) const; ///< get antenna phi position relative to ADU5 AFT-FORE line

//    Double_t getMeanAntPairPhiRelToAftFore(Int_t firstAnt, Int_t secondAnt, pueo::pol::pol_t pol=pueo::pol::kVertical) const; ///< The mean of the two antenna phi positions

    Int_t getTopAntNearestPhiWave(Double_t phiWave, pol::pol_t=pol::kVertical) const; ///< get antenna closest to given plane wave direction

    Int_t getUpperAntNearestPhiWave(Double_t phiWave, pol::pol_t pol=pol::kVertical) const;
    
    void getAntFaceXYZ(Int_t ant, Double_t &x, Double_t &y, Double_t &z) const; ///< get location fo antenna face in balloon cartesian coordinates

    Double_t getAntFaceZ(Int_t ant) const; ///< get z position for antenna face

    Double_t getAntFaceR(Int_t ant) const; ///< get r position for antenna face

    Double_t getAntFacePhiPosition(Int_t ant) const; ///< get phi position for antenna face

    Double_t getAntFacePhiPositionRelToAftFore(Int_t ant) const; ///< get phi position relative to ADU5 AFT-FORE direction

    Int_t getTopAntFaceNearestPhiWave(Double_t phiWave) const; ///< get upper antenna closest to given plane wave direction

    Int_t getUpperAntFaceNearestPhiWave(Double_t phiWave)  const{ return getTopAntFaceNearestPhiWave(phiWave);}///< get upper antenna closest to given plane wave direction

    double aftForeOffsetAngleVertical; 
    TVector3 fHeadingRotationAxis;
    TVector3 fPitchRotationAxis;
    TVector3 fRollRotationAxis;

    bool isValid() const { return valid ; }

    //Horn antenna positions
    std::array<double,k::NUM_HORNS> xAntHorns = {}; 
    std::array<double,k::NUM_HORNS> yAntHorns = {}; 
    std::array<double,k::NUM_HORNS> zAntHorns = {}; 
    std::array<double,k::NUM_HORNS> rAntHorns = {}; 
    std::array<double,k::NUM_HORNS> azCenterAntHorns = {}; 
    std::array<double,k::NUM_HORNS> azApertureAntHorns = {}; 
    std::array<double,k::NUM_HORNS> elAntHorns = {}; 

    // LF Antenna positions
    std::array<double,k::NANTS_LF> xAntLF = {}; 
    std::array<double,k::NANTS_LF> yAntLF = {}; 
    std::array<double,k::NANTS_LF> zAntLF = {}; 
    std::array<double,k::NANTS_LF> rAntLF = {}; 
    std::array<double,k::NANTS_LF> azCenterAntLF = {}; 
    std::array<double,k::NANTS_LF> azApertureAntLF = {}; 
    std::array<double,k::NANTS_LF> elAntLF = {}; 


    //Horn Antenna Phase Centers
    std::array<std::array<double,k::NUM_POLS>, k::NUM_HORNS> xPhaseCenterHorns = {}; 
    std::array<std::array<double,k::NUM_POLS>, k::NUM_HORNS> yPhaseCenterHorns = {}; 
    std::array<std::array<double,k::NUM_POLS>, k::NUM_HORNS> zPhaseCenterHorns = {}; 
    std::array<std::array<double,k::NUM_POLS>, k::NUM_HORNS> rPhaseCenterHorns = {}; 
    std::array<std::array<double,k::NUM_POLS>, k::NUM_HORNS> azPhaseCenterHorns {}; 

    //LF Antenna Phase Centers
    std::array<std::array<double,k::NUM_POLS>, k::NANTS_LF> xPhaseCenterLF = {}; 
    std::array<std::array<double,k::NUM_POLS>, k::NANTS_LF> yPhaseCenterLF = {}; 
    std::array<std::array<double,k::NUM_POLS>, k::NANTS_LF> zPhaseCenterLF = {}; 
    std::array<std::array<double,k::NUM_POLS>, k::NANTS_LF> rPhaseCenterLF = {}; 
    std::array<std::array<double,k::NUM_POLS>, k::NANTS_LF> azPhaseCenterLF {}; 

    static void getCartesianCoords(Double_t lat, Double_t lon, Double_t alt, Double_t p[3]);
    static void getLatLonAltFromCartesian(Double_t p[3], Double_t &lat, Double_t &lon, Double_t &alt);
    static Double_t getDistanceToCentreOfEarth(Double_t lat);




  private:
    GeomTool(int v, const std::string & src);
    bool valid;
    bool readPositions(int v, const std::string &src);
    pueo::data::GeometryReader r; 


  };



}
  
#endif 
